/* Data Exchange Server (DES) is a component of the Datacan Data2Desk (D2D) Platform.
License:

	[PROPER LEGALESE HERE...]

	INTERIM LICENSE DESCRIPTION:
	In spirit, this license:
	1. Allows <Third Party> to use, modify, and / or distributre this software in perpetuity so long as <Third Party> understands:
		a. The software is porvided as is without guarantee of additional support from DataCan in any form.
		b. The software is porvided as is without guarantee of exclusivity.

	2. Prohibits <Third Party> from taking any action which might interfere with DataCan's right to use, modify and / or distributre this software in perpetuity.
*/

package pkg

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/websocket/v2"
	"github.com/google/uuid" // go get github.com/google/uuid
)

const DES_APP = "DES v0.0.0"

const ROLE_SUPER = "super"
const ROLE_ADMIN = "admin"
const ROLE_OPERATOR = "operator"
const ROLE_VIEWER = "viewer"
const ROLE_DEVICE = "device"

func UserRole_Super(role interface{}) bool {
	return role == ROLE_SUPER
}
func UserRole_Admin(role interface{}) bool {
	return role == ROLE_SUPER || role == ROLE_ADMIN
}
func UserRole_Operator(role interface{}) bool {
	return role == ROLE_SUPER || role == ROLE_ADMIN || role == ROLE_OPERATOR
}
func UserRole_Viewer(role interface{}) bool { // fmt.Printf("\nUserRole_Viewer( %v )\n", role)
	return role == ROLE_SUPER || role == ROLE_ADMIN || role == ROLE_OPERATOR || role == ROLE_VIEWER
}
func UserRole_Device(role interface{}) bool {
	return role == ROLE_SUPER || role == ROLE_DEVICE
}

func GetSuperUser() (ures UserResponse, err error) {
	user := User{}
	res := DES.DB.First(&user, "role = ?", ROLE_SUPER)
	if res.Error != nil {
		err = res.Error
	}
	ures = user.FilterUserRecord()
	return
}

/* IF ANY REQURIRED DIRECTORY FAILS TO EXIST, ACTIVELY DISAGREE */
func ConfirmDESDirectories() (err error) {

	/* ENSURE THE DATA ROOT EXISTS:
	- WHERE ALL DATA GENERATED BY AND FOR DEVICES WILL RESIDE
	*/
	if err = ConfirmDirectory(DATA_DIR); err != nil {
		return LogErr(err)
	}

	/* ENSURE THE ARCHIVE ROOT EXISTS:
	- WHERE EACH OF THE DIRECTORIES BELOW WILL BE ARCHIVED
		BEFORE THE MAIN DES DATABASE IS DROPPED / MIGRATED ( DEVELOPMENT )
	*/
	if err = ConfirmDirectory(ARCHIVE_DIR); err != nil {
		return LogErr(err)
	}

	/* ENSURE THE JOB DATABASES ROOT EXISTS:
	- WHERE JOB DATABASES RESIDE
	*/
	if err = ConfirmDirectory(JOB_DBS); err != nil {
		return LogErr(err)
	}

	/* ENSURE THE JOB FILES ROOT EXISTS:
	- WHERE USER UPLOADED JOB FILES RESIDE BEFORE THEY ARE
		QUALIFIED / VALIDATED
		REGISTERED WITH THE DES
		CONVERTED TO JOB DATABASES
	*/
	if err = ConfirmDirectory(JOB_FILES); err != nil {
		return LogErr(err)
	}

	/* ENSURE THE ARCHIVE ROOT EXISTS:
	- WHERE DEVICE INITIALIZATION FILES RESIDE UNTIL
		THEY ARE USED TO RECOVER A PREVIOUSLY REGISTERED DEVICE ( DEVELOPMENT )  */
	if err = ConfirmDirectory(DEVICE_FILES); err != nil {
		return LogErr(err)
	}

	return
}
func ConfirmDirectory(name string) (err error) {

	// fmt.Printf("ConfirmDirectory( %s ): CREATING\n", name)
	if err = os.Mkdir(name, os.ModePerm); err != nil {
		if !os.IsExist(err) {
			/* THERE'S SOME OTHER ISSUE */
			fmt.Printf("ConfirmDirectory( %s ): ERROR: %s\n", name, err.Error())
			return
		}
		err = nil
	}
	fmt.Printf("ConfirmDirectory( %s ): CONFIRMED\n", name)
	return
}

/* MOVE ALL EXISTING JOB / DEVICE DATA TO ARCHIVE DIRECTORIES */
func ArchiveDESDirectories() (err error) {

	/* TIME OF ARCHIVING ALL EXISTING JOB / DEVICE DATA */
	t := time.Now().UTC()
	y := t.Year()
	m := int(t.Month())
	d := t.Day()
	h := t.Hour()
	min := t.Minute()
	s := t.Second()
	arc_time := fmt.Sprintf("%d%02d%02d_%02d%02d%02d", y, m, d, h, min, s)

	arc := fmt.Sprintf("%s/%s", ARCHIVE_DIR, arc_time)
	if err = os.Mkdir(arc, os.ModePerm); err != nil {
		if os.IsNotExist(err) {
			fmt.Printf("\nArchiveDESDirectories( data/... ): NOTHING TO ARCHIVE\n")
			err = nil
			return
		}
		/* THERE'S SOME OTHER ISSUE */
		fmt.Printf("\nArchiveDESDirectories( data/..., %s ): ERROR: %s\n", arc, err.Error())
		return
	}
	fmt.Printf("\nArchiveDESDirectories( data/..., %s )\n", arc)

	/* ARCHIVE ALL EXISTING JOB DATABASES */
	jdba := fmt.Sprintf("%s/%s", arc, JOB_DB_DIR)
	if err := ArchiveDirectory(JOB_DBS, jdba); err != nil {
		return LogErr(err)
	}

	/* ARCHIVE ALL EXISTING JOB FILES */
	jfa := fmt.Sprintf("%s/%s", arc, JOB_FILE_DIR)
	if err := ArchiveDirectory(JOB_FILES, jfa); err != nil {
		return LogErr(err)
	}

	/* ARCHIVE ALL EXISTING DEVICE FILES */
	dfa := fmt.Sprintf("%s/%s", arc, DEVICE_FILE_DIR)
	if err := ArchiveDirectory(DEVICE_FILES, dfa); err != nil {
		return LogErr(err)
	}

	/* DEMO -> NOT FOR PRODUCTION */
	if err := os.RemoveAll("demo"); err != nil {
		return LogErr(err)
	}
	return
}
func ArchiveDirectory(dir, arc string) (err error) {

	/* ONLY ARCHIVE dir IF IT EXISTS */
	if _, err = os.Stat(dir); err != nil {
		// fmt.Printf("ArchiveDirectory( %s ): ERROR: %s\n", dir, err.Error())
		if os.IsNotExist(err) {
			/* THERE'S SOME OTHER ISSUE */
			fmt.Printf("ArchiveDirectory( %s ): ERROR: %s\n", dir, err.Error())
			// return
		}
	}

	/* dir EXISTS, ARCHIVE IT */
	if err = os.Rename(dir, arc); err != nil {
		return
	}
	return
}

func ValidateUUIDString(u string) (ok bool) {
	if u == "" || u == "00000000-0000-0000-0000-000000000000" {
		return false
	}
	_, err := uuid.Parse(u)
	return err == nil
}

func ParseRequestBody(c *fiber.Ctx, obj interface{}) (err error) {

	// objType := reflect.TypeOf(obj)
	// fmt.Println(objType)
	// for _, f := range reflect.VisibleFields(objType) {
	// 	fmt.Printf("\nobjType field: %v\n", f.Name)
	// }

	if err = c.BodyParser(&obj); err != nil {
		err = fmt.Errorf("Invalid request body: %s", err.Error())
		return
	}

	return
}

func SendWSConnectionError(ws *websocket.Conn, txt string) {

	js, err := json.Marshal(&WSMessage{Type: "err", Data: txt})
	if err != nil {
		LogErr(err)
		return
	}
	ws.Conn.WriteJSON(string(js))
	ws.Close()
}

type WSMessage struct {
	Type string      `json:"type"`
	Data interface{} `json:"data"`
}

type Ping struct {
	Time int64 `json:"time"`
	OK   bool  `json:"ok"`
}

func (p *Ping) LatencyCheck() (ms int64, err error) {
	/* TODO : CHECK LATENCEY BETWEEN DEVICE PING TIME AND SERVER TIME */
	return
}

type PingsMap map[string]Ping

type DESRegistration struct {
	DESDev //`json:"des_dev"`
	DESJob //`json:"des_job"`
	DESJobSearch
}

/* TODO: LOOK INTO USING JSON FIELD FOR TOKEN... */
type DESJobSearch struct {
	DESJobSearchID int64  `gorm:"unique; primaryKey" json:"des_job_search_id"`
	DESJobToken    string `gorm:"not null" json:"des_job_token"`
	DESJobJson     string `json:"des_job_json"`
	DESJobKey      int64  `json:"des_job_key"`
	DESJob         DESJob `gorm:"foreignKey:DESJobKey; references:des_job_id" json:"-"`
}

func SearchDESJobsByToken(token string) (regs []DESRegistration, err error) {

	token = "%" + token + "%"

	qry := DES.DB.
		Table("des_job_searches").
		Select("des_devs.*, des_jobs.*").
		Joins("JOIN des_jobs ON des_job_searches.des_job_key = des_jobs.des_job_id").
		Joins("JOIN des_devs ON des_jobs.des_job_dev_id = des_devs.des_dev_id").
		Where("des_job_searches.des_job_token LIKE ?", token)

	res := qry.Scan(&regs)
	if res.Error != nil {
		err = fmt.Errorf("Failed to retrieve jobs from database: %s", res.Error.Error())
		return
	}
	return
}
func SearchDESJobsByRegion(lngMin, lngMax, latMin, latMax float32) (regs []DESRegistration, err error) {

	// token = "%" + token + "%"

	qry := DES.DB.
		Table("des_job_searches").
		Select("des_devs.*, des_jobs.*").
		Joins("JOIN des_jobs ON des_job_searches.des_job_key = des_jobs.des_job_id").
		Joins("JOIN des_devs ON des_jobs.des_job_dev_id = des_devs.des_dev_id").
		Where("( des_jobs.des_job_lng BETWEEN ? AND ? ) AND ( des_jobs.des_job_lat BETWEEN ? AND ? ) ", lngMin, lngMax, latMin, latMax)

	res := qry.Scan(&regs)
	if res.Error != nil {
		err = fmt.Errorf("Failed to retrieve jobs from database: %s", res.Error.Error())
		return
	}
	return
}
func SearchDESJobs(p DESSearchParam) (regs []DESRegistration, err error) {

	p.Token = "%" + p.Token + "%"

	qry := DES.DB.
		Table("des_job_searches").
		Select("des_devs.*, des_jobs.*").
		Joins("JOIN des_jobs ON des_job_searches.des_job_key = des_jobs.des_job_id").
		Joins("JOIN des_devs ON des_jobs.des_job_dev_id = des_devs.des_dev_id").
		Where(`
		( des_job_searches.des_job_token LIKE ? ) AND
		( des_jobs.des_job_lng BETWEEN ? AND ? ) AND 
		( des_jobs.des_job_lat BETWEEN ? AND ? ) AND 
		( des_jobs.des_job_name NOT LIKE '%_CMDARCHIVE' )`,
			p.Token, p.LngMin, p.LngMax, p.LatMin, p.LatMax)

	res := qry.Scan(&regs)
	if res.Error != nil {
		err = fmt.Errorf("Failed to retrieve jobs from database: %s", res.Error.Error())
		return
	}
	return
}
func SearchDESDevices(p DESSearchParam) (regs []DESRegistration, err error) {

	p.Token = "%" + strings.ToUpper(p.Token) + "%"

	/* WHERE MORE THAN ONE JOB IS ACTIVE ( des_job_end = 0 ) WE WANT THE LATEST */
	subQryLatestJob := DES.DB.
		Table("des_jobs").
		Select("des_job_dev_id, MAX(des_job_reg_time) AS max_time").
		Joins("JOIN des_job_searches ON des_jobs.des_job_id = des_job_searches.des_job_key").
		Where(`des_job_end = 0
		AND UPPER( des_job_searches.des_job_token ) LIKE ?
		AND des_jobs.des_job_lng BETWEEN ? AND ?
		AND des_jobs.des_job_lat BETWEEN ? AND ?
		`, p.Token, p.LngMin, p.LngMax, p.LatMin, p.LatMax).
		Group("des_job_dev_id")

	qry := DES.DB.
		Table("des_jobs").
		Distinct("des_devs.*, des_jobs.*").
		Joins(`JOIN ( ? ) j ON des_jobs.des_job_dev_id = j.des_job_dev_id AND des_job_reg_time = j.max_time`, subQryLatestJob).
		Joins("JOIN des_devs ON des_devs.des_dev_id = j.des_job_dev_id").
		Order("des_devs.des_dev_serial DESC")

	res := qry.Scan(&regs)
	if res.Error != nil {
		err = fmt.Errorf("Failed to retrieve devices from database: %s", res.Error.Error())
		return
	}
	return
}

type DESSearchParam struct {
	Token  string  `json:"token"`
	LngMin float64 `json:"lng_min"`
	LngMax float64 `json:"lng_max"`
	LatMin float64 `json:"lat_min"`
	LatMax float64 `json:"lat_max"`
}

/* TODO: LOOK INTO USING JSON FIELD FOR TOKEN... */
/* https://blog.davidvassallo.me/2022/12/14/inserting-reading-and-updating-json-data-in-postgres-using-golang-gorm/ */
// type JSONB map[string]interface{}
// func (jsonField JSONB) Value() (driver.Value, error) {
// 	return json.Marshal(jsonField)
// }
// func (jsonField *JSONB) Scan(value interface{}) error {
//     data, ok := value.([]byte)
//     if !ok {
//         return errors.New("type assertion to []byte failed")
//     }
//     return json.Unmarshal(data,&jsonField )
// }

// type DESJobSearchJSON struct {
// 	DESJobSearchID int64  `gorm:"unique; primaryKey" json:"des_job_search_id"`
// 	DESJobToken    JSONB `gorm:"type:jsonb" json:"des_job_token"`
// 	DESJobKey      int64  `json:"des_job_key"`
// 	DESJob         DESJob `gorm:"foreignKey:DESJobKey; references:des_job_id" json:"-"`
// }
